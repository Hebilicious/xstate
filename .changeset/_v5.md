## XState

If context types are specified in the machine config, the `context` property will now be required:

```ts
// ❌ TS error
createMachine({
  types: {} as {
    context: { count: number };
  }
  // Missing context property
});

// ✅ OK
createMachine({
  types: {} as {
    context: { count: number };
  },
  context: {
    count: 0
  }
});
```

---

The `state.events` property has been removed from the `State` object.

---

The `state.historyValue` property now more closely represents the original SCXML algorithm, and is a mapping of state node IDs to their historic descendent state nodes. This is used for resolving history states, and should be considered internal.

---

The `stateNode.isTransient` property is removed from `StateNode`.

---

The `.initial` property of a state node config object can now contain executable content (i.e., actions):

```js
// ...
initial: {
  target: 'someTarget',
  actions: [/* initial actions */]
}
```

---

Assign actions (via `assign()`) will now be executed "in order", rather than automatically prioritized. They will be evaluated after previously defined actions are evaluated, and actions that read from `context` will have those intermediate values applied, rather than the final resolved value of all `assign()` actions taken, which was the previous behavior.

This shouldn't change the behavior for most state machines. To maintain the previous behavior, ensure that `assign()` actions are defined before any other actions.

---

The `machine.transition(state, event, actorScope)` function has been changed; it expects a full state object, an event object, and an actor scope. The transition function is meant for internal use.

---

Fixed an issue with parallel regions sometimes not being correctly reentered when taking transitions targeting other parallel regions.

---

An error will be thrown if an `initial` state key is not specified for compound state nodes. For example:

```js
const lightMachine = createMachine({
  id: 'light',
  initial: 'green',
  states: {
    green: {},
    yellow: {},
    red: {
      // Forgotten initial state:
      // initial: 'walk',
      states: {
        walk: {},
        wait: {}
      }
    }
  }
});
```

You will get the error:

```
No initial state specified for state node "#light.red". Try adding { initial: "walk" } to the state config.
```

---

IDs for delayed events are no longer derived from event types so this won't work automatically:

```ts
entry: raise({ type: 'TIMER' }, { delay: 200 });
exit: cancel('TIMER');
```

Please use explicit IDs:

```ts
entry: raise({ type: 'TIMER' }, { delay: 200, id: 'myTimer' });
exit: cancel('myTimer');
```

---

The `machine.options` property has been renamed to `machine.implementations`

---

You can now `spawnChild(...)` to spawn child actors outside of `assign(...)` action creators:

```ts
import { createMachine, spawnChild } from 'xstate';

const listenerMachine = createMachine({
  // ...
});

const parentMachine = createMachine({
  // ...
  on: {
    'listener.create': {
      entry: spawnChild(listenerMachine, { id: 'listener' })
    }
  }
  // ...
});

const actor = createActor(parentMachine).start();

actor.send({ type: 'listener.create' });

actor.getSnapshot().children.listener; // ActorRefFrom<typeof listenerMachine>
```

---

Removed `State#toStrings` method.

---

The machine's `context` is now restricted to an `object`. This was the most common usage, but now the typings prevent `context` from being anything but an object:

```ts
const machine = createMachine({
  // This will produce the TS error:
  // "Type 'string' is not assignable to type 'object | undefined'"
  context: 'some string'
});
```

If `context` is `undefined`, it will now default to an empty object `{}`:

```ts
const machine = createMachine({
  // No context
});

const actor = createActor(machine).start();

actor.getSnapshot().context;
// => {}
```

---

`external` property on transitions has been renamed to `reenter`

---

`onSnapshot` is now available for invoke configs. You can specify a transition there to be taken when a snapshot of an invoked actor gets updated. It works similarly to `onDone`/`onError`.

---

Removed `MachineSnapshot['nextEvents']`.

---

Partial event descriptors are now type-safe:

```ts
createMachine({
  types: {} as {
    events:
      | { type: 'mouse.click.up'; direction: 'up' }
      | { type: 'mouse.click.down'; direction: 'down' }
      | { type: 'mouse.move' }
      | { type: 'keypress' };
  },
  on: {
    'mouse.click.*': {
      actions: ({ event }) => {
        event.type;
        // 'mouse.click.up' | 'mouse.click.down'
        event.direction;
        // 'up' | 'down'
      }
    },
    'mouse.*': {
      actions: ({ event }) => {
        event.type;
        // 'mouse.click.up' | 'mouse.click.down' | 'mouse.move'
      }
    }
  }
});
```

---

The `in: '...'` transition property can now be replaced with `stateIn(...)` and `stateNotIn(...)` guards, imported from `xstate/guards`:

```diff
import {
  createMachine,
+ stateIn
} from 'xstate/guards';

const machine = createMachine({
  // ...
  on: {
    SOME_EVENT: {
      target: 'anotherState',
-     in: '#someState',
+     cond: stateIn('#someState')
    }
  }
})
```

The `stateIn(...)` and `stateNotIn(...)` guards also can be used the same way as `state.matches(...)`:

```js
// ...
SOME_EVENT: {
  target: 'anotherState',
  cond: stateNotIn({ red: 'stop' })
}
```

---

Added support to `stateIn` guard for checking a combination of an ID and a path, eg. `stateIn('#b.B1')`.

---

Renamed `machine.withConfig(...)` to `machine.provide(...)`.

---

The `self` actor reference is now available in all action metas. This makes it easier to reference the "self" `ActorRef` so that actions such as `sendTo` can include it in the event payload:

```ts
// Sender
actions: sendTo('somewhere', (ctx, ev, { self }) => ({
  type: 'EVENT',
  ref: self
})),

// ...

// Responder
actions: sendTo((ctx, ev) => ev.ref, ...)
```

---

`isState`/`isStateConfig` were replaced by `isMachineSnapshot`. Similarly, `AnyState` type was deprecated and it's replaced by `AnyMachineSnapshot` type.

---

`State.from`, `StateMachine#createState` and `StateMachine#resolveStateValue` were removed. They largely served the same purpose as `StateMachine#resolveState` and this is the method that is still available and can be used instead of them.

---

The output data on final states is now specified as `.output` instead of `.data`:

```diff
const machine = createMachine({
  // ...
  states: {
    // ...
    success: {
-     data: { message: 'Success!' }
+     output: { message: 'Success!' }
    }
  }
})
```

---

Support for getters as a transition target (instead of referencing state nodes by ID or relative key) has been removed.

---

The `Machine()` and `createMachine()` factory functions no longer support passing in `context` as a third argument.

---

The `activities` property was removed from `State` objects, as activities are now part of `invoke` declarations.

---

The state nodes will not show the machine's `version` on them - the `version` property is only available on the root machine node.

---

The `in: ...` property for transitions is removed and replaced with guards. It is recommended to use `stateIn()` and `not(stateIn())` guard creators instead:

```diff
+ import { stateIn } from 'xstate';

// ...
on: {
  SOME_EVENT: {
    target: 'somewhere',
-   in: '#someState'
+   guard: stateIn('#someState')
  }
}
// ...
```

---

All builtin action creators (`assign`, `sendTo`, etc) are now returning _functions_. They exact shape of those is considered an implementation detail of XState and users are meant to only pass around the returned values.

---

Autoforwarding events is no longer supported and the `autoForward` property has been removed.

Instead of autoforwarding, events should be explicitly sent to actors:

```diff
invoke: {
  id: 'child',
  src: 'someSrc',
- autoForward: true
},
// ...
on: {
  // ...
+ EVENT_TO_FORWARD: {
+   actions: sendTo('child', ({ event }) => event)
+ }
}
```

---

The machine `.schema` property is now `.types`:

```ts
const machine = createMachine({
  // schema: { ... }
  types: {} as {
    context: { ... };
    events: { ... };
    // ...
  }
});
```

And the `.tsTypes` property is now `.types.typegen`:

```ts
const machine = createMachine({
  // tsTypes: { ... }
  types: {} as {
    typegen: {};
    context: { ... };
    events: { ... };
    // ...
  }
});
```

---

Params of `actions` and `guards` can now be resolved dynamically

```ts
createMachine({
  types: {} as {
    actions: { type: 'greet'; params: { surname: string } } | { type: 'poke' };
  },
  entry: {
    type: 'greet',
    params: ({ context }) => ({
      surname: 'Doe'
    })
  }
});
```

---

There is now support for higher-level guards, which are guards that can compose other guards:

- `and([guard1, guard2, /* ... */])` returns `true` if _all_ guards evaluate to truthy, otherwise `false`
- `or([guard1, guard2, /* ... */])` returns `true` if _any_ guard evaluates to truthy, otherwise `false`
- `not(guard1)` returns `true` if a single guard evaluates to `false`, otherwise `true`

```js
import { and, or, not } from 'xstate/guards';

const someMachine = createMachine({
  // ...
  on: {
    EVENT: {
      target: 'somewhere',
      guard: and([
        'stringGuard',
        or([{ type: 'anotherGuard' }, not(() => false)])
      ])
    }
  }
});
```

---

Actions and guards that follow eventless transitions will now receive the event that triggered the transition instead of a "null" event (`{ type: '' }`), which no longer exists:

```js
// ...
states: {
  a: {
    on: {
      SOME_EVENT: 'b'
    }
  },
  b: {
    always: 'c'
  },
  c: {
    entry: [(_, event) => {
      // event.type is now "SOME_EVENT", not ""
    }]
  }
}
// ...
```

---

`machine.initialState` has been removed, you can use `machine.getInitialState(...)` instead

---

Target resolution improvements: targeting sibling nodes from the root is no longer valid, since the root node has no siblings:

```diff
createMachine({
  id: 'direction',
  initial: 'left',
  states: {
    left: {},
    right: {}
  },
  on: {
-   LEFT_CLICK: 'left',
+   LEFT_CLICK: '.left'
  }
});
```

---

Atomic and parallel states should no longer be reentered when the transition target doesn't escape them. You can get the reentering behavior by configuring `reenter: true` for the transition.

---

An error will now be thrown if the `assign(...)` action is executed when the `context` is `undefined`. Previously, there was only a warning.

---

Action/actor/delay/guard arguments are now consolidated into a single object argument. This is a breaking change for all of those things that are called with arguments.

```diff
assign({
- count: (context, event) => {
+ count: ({ context, event }) => {
    return context.count + event.value;
  }
})
```

```diff
- guard: (context, event) => {
+ guard: ({ context, event }) => {
  return context.count + event.value > 10;
}
```

---

Eventless transitions must now be specified in the `always: { ... }` object and not in the `on: { ... }` object:

```diff
someState: {
  on: {
    // Will no longer work
-   '': { target: 'anotherState' }
  },
+ always: { target: 'anotherState' }
}
```

---

Removed the ability to pass a string value directly to `invoke`. To migrate you should use the object version of `invoke`:

```diff
-invoke: 'myActor'
+invoke: { src: 'myActor' }
```

---

`machine.transition(...)` and `machine.getInitialState(...)` now require a third `actorScope` argument

---

```ts
createMachine({
  types: {} as {
    guards:
      | {
          type: 'isGreaterThan';
          params: {
            count: number;
          };
        }
      | { type: 'plainGuard' };
  }
  // ...
});
```

---

All events automatically generated by XState will now be prefixed by `xstate.`. Naming scheme changed slightly as well, for example `done.invoke.*` events became `xstate.done.actor.*` events.

---

The `escalate()` action is removed. Just throw an error normally.

---

You can now define strict tags for machines:

```ts
createMachine({
  types: {} as {
    tags: 'pending' | 'success' | 'error';
  }
  // ...
});
```

---

The `actor.onTransition(...)` method has been removed in favor of `.subscribe(...)`

```diff
 const actor = createActor(machine)
-  .onTransition(...)
-  .start();
+actor.subscribe(...);
+actor.start();
```

---

Observing an actor via `actor.subscribe(...)` no longer immediately receives the current snapshot. Instead, the current snapshot can be read from `actor.getSnapshot()`, and observers will receive snapshots only when a transition in the actor occurs.

```ts
const actor = createActor(machine);
actor.start();

// Late subscription; will not receive the current snapshot
actor.subscribe((state) => {
  // Only called when the actor transitions
  console.log(state);
});

// Instead, current snapshot can be read at any time
console.log(actor.getSnapshot());
```

---

Actors can no longer be stopped directly by calling ~~`actor.stop()`~~. They can only be stopped from its parent internally (which might happen when you use `stop` action or automatically when a machine leaves the invoking state). The root actor can still be stopped since it has no parent.

---

Remove `State['changed']`. A new instance of `State` is being created if there are matching transitions for the received event. If there are no matching transitions then the current state is being returned.

---

The `state.configuration` property has been renamed to `state._nodes`.

```diff
- state.configuration
+ state._nodes
```

---

The `matchState(...)` helper function is removed.

---

Parameterized actions now require a `params` property:

```diff
// ...
entry: [
  {
    type: 'greet',
-   message: 'Hello'
+   params: { message: 'Hello' }
  }
]
// ...
```

---

The history resolution algorithm has been refactored to closely match the SCXML algorithm, which changes the shape of `state.historyValue` to map history state node IDs to their most recently resolved target state nodes.

---

The `spawn(...)` action creator has been renamed to `spawnChild(...)` to avoid confusion.

```ts
import { spawnChild, assign } from 'xstate';

const childMachine = createMachine({
  on: {
    someEvent: {
      actions: [
        // spawnChild(...) instead of spawn(...)
        spawnChild('someSrc'),

        // spawn() is used inside of assign()
        assign({
          anotherRef: ({ spawn }) => spawn('anotherSrc')
        })
      ]
    }
  }
});
```

---

The `onSnapshot: { ... }` transition object is now supported for invoked machines, observables, promises, and transition functions:

```ts
const machine = createMachine({
  // ...
  invoke: [
    {
      src: createMachine({ ... }),
      onSnapshot: {
        actions: (context, event) => {
          event.snapshot; // machine state
        }
      }
    },
    {
      src: fromObservable(() => ...),
      onSnapshot: {
        actions: (context, event) => {
          event.snapshot; // observable value
        }
      }
    },
    {
      src: fromTransition((state, event) => { ... }, /* ... */),
      onSnapshot: {
        actions: (context, event) => {
          event.snapshot; // transition function return value
        }
      }
    }
  ]
});
```

---

Custom action objects and guard objects are now expected to put extra parameters on the `params` property:

```diff
actions: {
  type: 'sendMessage',
- message: 'hello'
+ params: {
+   message: 'hello'
+ }
}
guard: {
  type: 'exists',
- prop: 'user'
+ params: {
+   prop: 'user'
+ }
}
```

---

The `strict: true` option for machine config has been removed.

---

Removed the ability to define delayed transitions using an array. Only object variant is supported now:

```ts
createMachine({
  initial: 'a',
  states: {
    a: {
      after: {
        10000: 'b',
        noon: 'c'
      }
    }
    // ...
  }
});
```

---

The `stop(...)` action creator is renamed to `stopChild(...)`, to make it clear that only child actors may be stopped from the parent actor.

---

Removed `State['transitions']`.

---

Removed the deprecated `send` action creator. Please use `sendTo` when sending events to other actors or `raise` when sending to itself.

---

Action parameters can now be directly accessed from the 2nd argument of the action implementation:

```ts
const machine = createMachine(
  {
    // ...
    entry: {
      type: 'greet',
      params: { message: 'hello' }
    }
  },
  {
    actions: {
      greet: (_, params) => {
        params.message; // 'hello'
      }
    }
  }
);
```

---

The `createEmptyActor()` function has been added to make it easier to create actors that do nothing ("empty" actors). This is useful for testing, or for some integrations such as `useActor(actor)` in `@xstate/react` that require an actor:

```jsx
import { createEmptyActor } from 'xstate';

const SomeComponent = (props) => {
  // props.actor may be undefined
  const [state, send] = useActor(props.actor ?? createEmptyActor());

  // ...
};
```

---

Input types can now be specified for machines:

```ts
const emailMachine = createMachine({
  types: {} as {
    input: {
      subject: string;
      message: string;
    };
  },
  context: ({ input }) => ({
    // Strongly-typed input!
    emailSubject: input.subject,
    emailBody: input.message.trim()
  })
});

const emailActor = createActor(emailMachine, {
  input: {
    // Strongly-typed input!
    subject: 'Hello, world!',
    message: 'This is a test.'
  }
}).start();
```

---

`machine.transition` no longer accepts state values. You have to resolve the state value to a `State` before passing it to `machine.transition`

---

The `state.history` property has been removed. This does not affect the machine "history" mechanism.

Storing previous state should now be done explicitly:

```js
let previousState;

const service = createActor(someMachine)
  .onTransition((state) => {
    // previousState represents the last state here

    // ...

    // update the previous state at the end
    previousState = state;
  })
  .start();
```

---

`xstate.done.state.*` events will now be generated recursively for all parallel states on the ancestors path.

---

You can now import the following from `xstate`:

```js
import {
  // actions
  sendTo

  // interpret helpers
  waitFor,

  // actor functions
  fromPromise,
  fromObservable,
  fromCallback,
  fromEventObservable,
  fromTransition,

  // guard functions
  stateIn,
  not,
  and,
  or
}
```

The `send` action was removed from exports; use `sendTo(...)` or `raise(...)` instead.

---

The `cond` property in transition config objects has been renamed to `guard`. This unifies terminology for guarded transitions and guard predicates (previously called "cond", or "conditional", predicates):

```diff
someState: {
  on: {
    EVENT: {
      target: 'anotherState',
-     cond: 'isValid'
+     guard: 'isValid'
    }
  }
}
```

---

The `Machine()` function has been removed. Use the `createMachine()` function instead.

```diff
-import { Machine } from 'xstate';
+import { createMachine } from 'xstate';

-const machine = Machine({
+const machine = createMachine({
  // ...
});
```

---

Actions are no longer called with `state`

---

`spawn` is no longer importable from `xstate`. Instead you get it in `assign` like this:

```js
assign((ctx, ev, { spawn }) => {
  return {
    ...ctx,
    actorRef: spawn(promiseActor)
  };
});
```

In addition to that, you can now `spawn` actors defined in your implementations object, in the same way that you were already able to do that with `invoke`. To do that just reference the defined actor like this:

```js
spawn('promiseActor');
```

---

`State` class has been removed and replaced by `MachineSnapshot` object. They largely have the same properties and methods. On of the main noticeable results of this change is that you can no longer check `state instanceof State`.

---

The `StateSchema` type has been removed from all generic type signatures.

---

Removed `State['_internalQueue']`.

---

Make it impossible to exit a root state. For example, this means that root-level transitions specified as external transitions will no longer restart root-level invocations. See [#3072](https://github.com/statelyai/xstate/issues/3072) for more details.

---

Guard objects can now reference other guard objects:

```ts
const machine = createMachine(
  {
    initial: 'home',
    states: {
      home: {
        on: {
          NEXT: {
            target: 'success',
            guard: 'hasSelection'
          }
        }
      },
      success: {}
    }
  },
  {
    guards: {
      // `hasSelection` is a guard object that references the `stateIn` guard
      hasSelection: stateIn('selected')
    }
  }
);
```

---

The `pure()` and `choose()` action creators have been removed, in favor of the more flexible `enqueueActions()` action creator:

```ts
entry: [
  // pure(() => {
  //   return [
  //     'action1',
  //     'action2'
  //   ]
  // }),
  enqueueActions(({ enqueue }) => {
    enqueue('action1');
    enqueue('action2');
  })
];
```

```ts
entry: [
  // choose([
  //   {
  //     guard: 'someGuard',
  //     actions: ['action1', 'action2']
  //   }
  // ]),
  enqueueActions(({ enqueue, check }) => {
    if (check('someGuard')) {
      enqueue('action1');
      enqueue('action2');
    }
  })
];
```

---

Changed behavior of `always` transitions. Previously they were always selected after selecting any transition (including the `always` transitions). Because of that it was relatively easy to create an infinite loop using them.

Now they are no longer selected if the preceeding transition doesn't change the state of a machine.

---

The `state.children` property is now a mapping of invoked actor IDs to their `ActorRef` instances.

---

`_event` has been removed from all APIs and types. It was a wrapper structure containing the `event` that users were using directly.

---

Guard parameters can now be directly accessed from the 2nd argument of the guard implementation:

```ts
const machine = createMachine(
  {
    // ...
    on: {
      EVENT: {
        guard: {
          type: 'isGreaterThan',
          params: { value: 10 }
        }
      }
    }
  },
  {
    guards: {
      isGreaterThan: (_, params) => {
        params.value; // 10
      }
    }
  }
);
```

---

Added support for expressions to `cancel` action.

---

The new `enqueueActions(...)` action creator can now be used to enqueue actions to be executed. This is a helpful alternative to the `pure(...)` and `choose(...)` action creators.

```ts
const machine = createMachine({
  // ...
  entry: enqueueActions(({ context, event, enqueue, check }) => {
    // assign action
    enqueue.assign({
      count: context.count + 1
    });

    // Conditional actions (replaces choose(...))
    if (event.someOption) {
      enqueue.sendTo('someActor', { type: 'blah', thing: context.thing });

      // other actions
      enqueue('namedAction');
      // with params
      enqueue({ type: 'greet', params: { message: 'hello' } });
    } else {
      // inline
      enqueue(() => console.log('hello'));

      // even built-in actions
    }

    // Use check(...) to conditionally enqueue actions based on a guard
    if (check({ type: 'someGuard' })) {
      // ...
    }

    // no return
  })
});
```

---

- Breaking: activities removed (can be invoked)

Since activities can be considered invoked services, they can be implemented as such. Activities are services that do not send any events back to the parent machine, nor do they receive any events, other than a "stop" signal when the parent changes to a state where the activity is no longer active. This is modeled the same way as a callback service is modeled.

---

You can now specify action types for machines:

```ts
createMachine({
  types: {} as {
    actions: { type: 'greet'; params: { name: string } };
  },
  entry: [
    {
      type: 'greet',
      params: {
        name: 'David'
      }
    },
    // @ts-expect-error
    { type: 'greet' },
    // @ts-expect-error
    { type: 'unknownAction' }
  ]
  // ...
});
```

---

Removed previously deprecated config properties: `onEntry`, `onExit`, `parallel` and `forward`.

---

The `state._sessionid` property has been removed. It should be obtained directly from the actor: `actor.sessionId`.

---

Typings for `Typestate` have been removed. The reason for this is that types for typestates needed to be manually specified, which is unsound because it is possible to specify _impossible_ typestates; i.e., typings for a state's `value` and `context` that are impossible to achieve.

---

The `createModel()` function has been removed in favor of relying on strong types in the machine configuration.

---

`sync` option has been removed from `invoke` and `spawn`.

---

Removed `State['event']`.

---

The `state.meta` getter has been replaced with `state.getMeta()` methods:

```diff
- state.meta
+ state.getMeta()
```

---

The final `output` of a state machine is now specified directly in the `output` property of the machine config:

```ts
const machine = createMachine({
  initial: 'started',
  states: {
    started: {
      // ...
    },
    finished: {
      type: 'final'
      // moved to the top level
      //
      // output: {
      //   status: 200
      // }
    }
  },
  // This will be the final output of the machine
  // present on `snapshot.output` and in the done events received by the parent
  // when the machine reaches the top-level final state ("finished")
  output: {
    status: 200
  }
});
```

---

Output types can now be specified in the machine:

```ts
const machine = createMachine({
  types: {} as {
    output: {
      result: 'pass' | 'fail';
      score: number;
    };
  }
  // ...
});

const actor = createActor(machine);

// ...

const snapshot = actor.getSnapshot();

if (snapshot.output) {
  snapshot.output.result;
  // strongly typed as 'pass' | 'fail'
  snapshot.output.score;
  // strongly typed as number
}
```

---

Removed `mapState` utility function.

---

Removed the ability to configure transitions using arrays:

```ts
createMachine({
  on: [{ event: 'FOO', target: '#id' }]
  // ...
});
```

Only regular object-based configs will be supported from now on:

```ts
createMachine({
  on: {
    FOO: '#id'
  }
  // ...
});
```

---

You can now use the `setup({ ... }).createMachine({ ... })` function to setup implementations for `actors`, `actions`, `guards`, and `delays` that will be used in the created machine:

```ts
import { setup, createMachine } from 'xstate';

const fetchUser = fromPromise(async ({ input }) => {
  const response = await fetch(`/user/${input.id}`);
  const user = await response.json();
  return user;
});

const machine = setup({
  actors: {
    fetchUser
  },
  actions: {
    clearUser: assign({ user: undefined })
  },
  guards: {
    isUserAdmin: (_, params) => params.user.role === 'admin'
  }
}).createMachine({
  // ...
  invoke: {
    // Strongly typed!
    src: 'fetchUser',
    input: ({ context }) => ({ id: context.userId }),
    onDone: {
      guard: {
        type: 'isUserAdmin',
        params: ({ context }) => ({ user: context.user })
      },
      target: 'success',
      actions: assign({ user: ({ event }) => event.output })
    },
    onError: {
      target: 'failure',
      actions: 'clearUser'
    }
  }
});
```

---

Prefix wildcard event descriptors are now supported. These are event descriptors ending with `".*"` which will match all events that start with the prefix (the partial event type before `".*"`):

```js
// ...
on: {
  'mouse.click': {/* ... */},
  // Matches events such as:
  // "pointer.move"
  // "pointer.move.out"
  // "pointer"
  'pointer.*': {/* ... */}
}
// ...
```

Note: wildcards are only valid as the entire event type (`"*"`) or at the end of an event type, preceded by a period (`".*"`):

- ✅ `"*"`
- ✅ `"event.*"`
- ✅ `"event.something.*"`
- ❌ ~`"event.*.something"`~
- ❌ ~`"event*"`~
- ❌ ~`"event*.some*thing"`~
- ❌ ~`"*.something"`~

---

The interface for guard objects has changed. Notably, all guard parameters should be placed in the `params` property of the guard object:

Example taken from [Custom Guards](https://xstate.js.org/docs/guides/guards.html#custom-guards):

```diff
-cond: {
+guard: {
- name: 'searchValid', // `name` property no longer used
  type: 'searchValid',
- minQueryLength: 3
+ params: {
+   minQueryLength: 3
+ }
}
```

---

All transitions became internal by default. The style of the `target` pattern (`.child`, `sibling`, `#id`) has now no effect on the transition type.

Internal transitions don't reenter their source state when the target lies within it. You can still create external transitions (ones that reenter the source state under the mentioned circumstances) by explicitly setting `external: true` on the given transition.

---

You can now specify delay types for machines:

```ts
createMachine({
  types: {} as {
    delays: 'one second' | 'one minute';
  }
  // ...
});
```

---

The event type of internal `after` events changed from `xstate.after(1000)#some.state.id` to `xstate.after.1000.some.state.id` for consistency.

---

`exit` actions of all states are no longer called when the machine gets stopped externally. Note that they are still called when the machine reaches its final state.

---

State values and `snapshot.matches()` argument are now strongly-typed when using the `setup` API.

---

Removed `State['actions']`. Actions are considered to be a side-effect of a transition, things that happen in the moment and are not meant to be persisted beyond that.

---

The `state` option of `createActor(...)` has been renamed to `snapshot`:

```diff
createActor(machine, {
- state: someState
+ snapshot: someState
})
```

Likewise, the `.getPersistedState()` method has been renamed to `.getPersistedSnapshot()`:

```diff
-actor.getPersistedState()
+actor.getPersistedSnapshot()
```

---

`spawn` can now benefit from the actor types. Its arguments are strongly-typed based on them.

---

Significant improvements to error handling have been made:

- Actors will no longer crash when an error is thrown in an observer (`actor.subscribe(observer)`).
- Errors will be handled by observer's `.error()` handler:
  ```ts
  actor.subscribe({
    error: (error) => {
      // handle error
    }
  });
  ```
- If an observer does not have an error handler, the error will be thrown in a clear stack so bug tracking services can collect it.

---

Actors are now always part of a "system", which is a collection of actors that can communicate with each other. Systems are implicitly created, and can be used to get and set references to any actor in the system via the `systemId` prop:

```js
const machine = createMachine({
  // ...
  invoke: {
    src: emailMachine,
    // Registers `emailMachine` as `emailer` on the system
    systemId: 'emailer'
  }
});
```

```js
const machine = createMachine({
  // ...
  entry: assign({
    emailer: ({ spawn }) => spawn(emailMachine, { systemId: 'emailer' })
  })
});
```

Any invoked/spawned actor that is part of a system will be able to reference that actor:

```js
const anotherMachine = createMachine({
  // ...
  entry: sendTo(
    (ctx, ev, { system }) => {
      return system.get('emailer');
    },
    { type: 'SEND_EMAIL', subject: 'Hello', body: 'World' }
  )
});
```

Each top-level `createActor(...)` call creates a separate implicit system. In this example example, `actor1` and `actor2` are part of different systems and are unrelated:

```js
// Implicit system
const actor1 = createActor(machine).start();

// Another implicit system
const actor2 = createActor(machine).start();
```

---

The `actor.onStop(...)` (prev. `interpreter.onStop(...)`) method has been removed. Use an observer via `actor.subscribe({ complete() { ... } })` instead.

---

Sending a string event to `actor.send('some string')` will now throw a proper error message.

---

All actor snapshots now have a consistent, predictable shape containing these common properties:

- `status`: `'active' | 'done' | 'error' | 'stopped'`
- `output`: The output data of the actor when it has reached `status: 'done'`
- `error`: The error thrown by the actor when it has reached `status: 'error'`
- `context`: The context of the actor

This makes it easier to work with actors in a consistent way, and to inspect their snapshots.

```ts
const promiseActor = fromPromise(async () => {
  return 42;
});

// Previously number | undefined
// Now a snapshot object with { status, output, error, context }
const promiseActorSnapshot = promiseActor.getSnapshot();

if (promiseActorSnapshot.status === 'done') {
  console.log(promiseActorSnapshot.output); // 42
}
```

---

Restoring persisted state is now done by passing the state into the `snapshot: ...` property of the `createActor` options argument:

```diff
-createActor(machine).start(state);
+createActor(machine, { snapshot }).start();
```

The persisted snapshot (state) is obtained from an actor by calling `actor.getPersistedSnapshot()`:

```ts
const actor = createActor(machine).start();

const persistedSnapshot = actor.getPersistedSnapshot();

// ...

const restoredActor = createActor(machine, {
  snapshot: persistedSnapshot
}).start();
```

---

The `execute` option for an actor (prev. interpreted service) has been removed. If you don't want to execute actions, it's recommended that you don't hardcode implementation details into the base `machine` that will be interpreted, and extend the machine's `options.actions` instead. By default, the actor will execute all actions according to SCXML semantics (immediately upon transition).

---

These handlers have been removed, as they are redundant and can all be accomplished with `.onTransition(...)` and/or `.subscribe(...)`:

- `service.onEvent()`
- `service.onSend()`
- `service.onChange()`

---

The `service.send(...)` method no longer returns the next state. It is a `void` function (fire-and-forget).

---

The `service.sender(...)` method has been removed as redundant. Use `service.send(...)` instead.

---

Removed `actor.status` (prev. `interpreter.status`) from publicly available properties.

---

The `.send(...)` method on `actor.send(...)` now requires the first argument (the event to send) to be an _object_; that is, either:

- an event object (e.g. `{ type: 'someEvent' }`)
- an SCXML event object.

The second argument (payload) is no longer supported, and should instead be included within the object:

```diff
-actor.send('SOME_EVENT')
+actor.send({ type: 'SOME_EVENT' })

-actor.send('EVENT', { some: 'payload' })
+actor.send({ type: 'EVENT', some: 'payload' })
```

---

Reading the initial state from an actor via `actor.initialState` is removed. Use `actor.getInitialState()` instead.

---

The `createActor(...)` function now accepts `input` in the second argument, which passes input data in the `"xstate.init"` event:

```js
const greetMachine = createMachine({
  context: ({ input }) => ({
    greeting: `Hello ${input.name}!`
  }),
  entry: (_, event) => {
    event.type; // 'xstate.init'
    event.input; // { name: 'David' }
  }
  // ...
});

const actor = createActor(greetMachine, {
  // Pass input data to the machine
  input: { name: 'David' }
}).start();
```

---

Invoked actors can now be deeply persisted and restored. When the persisted state of an actor is obtained via `actor.getPersistedState()`, the states of all invoked actors are also persisted, if possible. This state can be restored by passing the persisted state into the `state: ...` property of the `createActor` options argument:

```diff
-interpret(machine).start(state);
+createActor(machine, { state }).start();
```

---

Restored state will no longer contain actions, since they are assumed to have already been executed. Actions will not be replayed.

If you want to replay actions when restoring state, it is recommended to use an event sourcing approach.

---

The order of type parameters in `ActorRef` has been changed from from `ActorRef<TEvent, TSnapshot>` to `ActorRef<TSnapshot, TEvent>` for consistency with other types.

---

Removed `deferEvents` from the actor options.

---

All errors caught while executing the actor should now consistently include the error in its `snapshot.error` and should be reported to the closest `error` listener.

---

Actor logic creators now have access to `self`:

```ts
const promiseLogic = fromPromise(({ self }) => { ... });

const observableLogic = fromObservable(({ self }) => { ... });

const callbackLogic = fromCallback((sendBack, receive, { self }) => { ... });

const transitionLogic = fromTransition((state, event, { self }) => { ... }, ...);
```

---

The `interpreter.onError(...)` method has been removed. Use `actor.subscribe({ error(err) => { ... } })` instead.

---

The `service.batch(events)` method is no longer available.

---

The way that you interface with invoked/spawned actors is now through `ActorRef` instances. An `ActorRef` is an opaque reference to an `Actor`, which should not be referenced directly.

---

The `services` option passed as the second argument to `createMachine(config, options)` is renamed to `actors`. Each value in `actors` should be a function that takes in `context` and `event` and returns a [behavior](TODO: link) for an actor. The provided behavior creators are:

- `fromMachine`
- `fromPromise`
- `fromCallback`
- `fromObservable`
- `fromEventObservable`

```diff
import { createMachine } from 'xstate';
+import { fromPromise } from 'xstate/actors';

const machine = createMachine(
  {
    // ...
    invoke: {
      src: 'fetchFromAPI'
    }
  },
  {
-   services: {
+   actors: {
-     fetchFromAPI: (context, event) => {
+     fetchFromAPI: (context, event) => fromPromise(() => {
        // ... (return a promise)
      })
    }
  }
);
```

---

The `actor.off(...)` (prev. `interpreter.off(...)`) method has been removed.

---

You can now inspect actor system updates using the `inspect` option in `createActor(logic, { inspect })`. The types of **inspection events** you can observe include:

- `@xstate.actor` - An actor ref has been created in the system
- `@xstate.event` - An event was sent from a source actor ref to a target actor ref in the system
- `@xstate.snapshot` - An actor ref emitted a snapshot due to a received event

```ts
import { createMachine } from 'xstate';

const machine = createMachine({
  // ...
});

const actor = createActor(machine, {
  inspect: (inspectionEvent) => {
    if (inspectionEvent.type === '@xstate.actor') {
      console.log(inspectionEvent.actorRef);
    }

    if (inspectionEvent.type === '@xstate.event') {
      console.log(inspectionEvent.sourceRef);
      console.log(inspectionEvent.targetRef);
      console.log(inspectionEvent.event);
    }

    if (inspectionEvent.type === '@xstate.snapshot') {
      console.log(inspectionEvent.actorRef);
      console.log(inspectionEvent.event);
      console.log(inspectionEvent.snapshot);
    }
  }
});
```

---

The `actor.nextState(...)` method has been removed from the `Actor` (prev. `Interpreter`). `state.can(...)` can be used to check if sending a particular event would lead to a state change.

---

The default `timeout` for `waitFor(...)` is now `Infinity` instead of 10 seconds.

---

---

Merge `sendBack` and `receive` with other properties of `fromCallback` logic creator.

```ts
const callbackLogic = fromCallback(({ input, system, self, sendBack, receive }) => { ... });
```

---

Returning promises when creating a callback actor doesn't work anymore. Only cleanup functions can be returned now (or `undefined`).

---

The `system` can now be accessed in all available actor logic creator functions:

```ts
fromPromise(({ system }) => { ... });

fromTransition((state, event, { system }) => { ... });

fromObservable(({ system }) => { ... });

fromEventObservable(({ system }) => { ... });

fromCallback((sendBack, receive, { system }) => { ... });
```

---

The `actor.onDone(...)` method is removed. Use `actor.subscribe({ complete() {... } })` instead.

```diff
- actor.onDone(() => { ... })
+ actor.subscribe({
+  complete() {
+    // ...
+  }
+})
```

---

Inspection events are now exported:

```ts
import type {
  InspectedActorEvent,
  InspectedEventEvent,
  InspectedSnapshotEvent,
  InspectionEvent
} from 'xstate';
```

---

Invoked/spawned actors are no longer available on `service.children` - they can only be accessed from `state.children`.

---

Added interop observable symbols to `ActorRef` so that actor refs are compatible with libraries like RxJS.

---

The `interpret(...)` function has been deprecated and renamed to `createActor(...)`:

```diff
-import { interpret } from 'xstate';
+import { createActor } from 'xstate';

-const actor = interpret(machine);
+const actor = createActor(machine);
```

---

Removed support for `service.send(type, payload)`. We are using `send` API at multiple places and this was the only one supporting this shape of parameters. Additionally, it had not strict TS types and using it was unsafe (type-wise).

---

Spawned actors that have a referenced source (not inline) can be deeply persisted and restored:

```ts
const machine = createMachine({
  context: ({ spawn }) => ({
    // This will be persisted
    ref: spawn('reducer', { id: 'child' })

    // This cannot be persisted:
    // ref: spawn(fromTransition((s) => s, { count: 42 }), { id: 'child' })
  })
}).provide({
  actors: {
    reducer: fromTransition((s) => s, { count: 42 })
  }
});
```

---

## `@xstate/react`

The `useMachine` function is aliased to `useActor`

---

Removed the ability to pass a factory function as argument to `useMachine` and `useInterpret`.

---

`useActorRef` is introduced, which returns an `ActorRef` from actor logic:

```ts
const actorRef = useActorRef(machine, { ... });
const anotherActorRef = useActorRef(fromPromise(...));
```

~~`useMachine`~~ is deprecated in favor of `useActor`, which works with machines and any other kind of logic

```diff
-const [state, send] = useMachine(machine);
+const [state, send] = useActor(machine);
const [state, send] = useActor(fromTransition(...));
```

~~`useSpawn`~~ is removed in favor of `useActorRef`

````diff
-const actorRef = useSpawn(machine);
+const actorRef = useActorRef(machine);

The previous use of `useActor(actorRef)` is now replaced with just using the `actorRef` directly, and with `useSelector`:

```diff
-const [state, send] = useActor(actorRef);
+const state = useSelector(actorRef, s => s);
// actorRef.send(...)
````

---

Fast refresh now works as expected for most use-cases.

---

The `options` prop has been added (back) to the `Context.Provider` component returned from `createActorContext`:

```tsx
const SomeContext = createActorContext(someMachine);

// ...

<SomeContext.Provider options={{ input: 42 }}>
  {/* ... */}
</SomeContext.Provider>;
```

---

`useActor` has been removed from the created actor context, you should be able to replace its usage with `MyCtx.useSelector` and `MyCtx.useActorRef`.

---

FSM-related functions have been removed.

---

Implementations for machines on `useMachine`/`useActor` and `useActorRef` hooks should go directly on the machine via `machine.provide(...)`, and are no longer allowed to be passed in as options.

```diff
-const [state, send] = useMachine(machine, {
-  actions: {
-    // ...
-  }
-});
+const [state, send] = useMachine(machine.provide({
+  actions: {
+    // ...
+  }
+}));
```

`@xstate/react` will detect that the machine's config is still the same, and will not produce the "machine has changed" warning.

---

The `observerOrListener` argument has been removed from the 3rd argument of `createActorContext(logic, options)`.

---

Removed `getSnapshot` parameter from hooks. It is expected that the received `actorRef` has to have a `getSnapshot` method on it that can be used internally.

---

The `useInterpret(machine)` and `useSpawn(machine)` hooks have been removed; use the `useActorRef(machine)` hook instead.

---

## `@xstate/svelte`

The `useMachine(machine)` hook now returns `{ snapshot, send, actorRef }` instead of `{ state, send, service }`:

```diff
const {
- state,
+ snapshot,
  send,
- service
+ actorRef
} = useMachine(machine);
```

---

FSM-related functions have been removed.

---

The `useActorRef(logic)` and `useActor(logic)` hooks have been added.

---

## `@xstate/vue`

The `useMachine(machine)` hook now returns `{ snapshot, send, actorRef }` instead of `{ state, send, service }`:

```diff
const {
- state,
+ snapshot,
  send,
- service
+ actorRef
} = useMachine(machine);
```

---

Removed `getSnapshot` parameter from composables. It is expected that the received `actorRef` has to have a `getSnapshot` method on it that can be used internally.

---

FSM-related functions have been removed.

---

## `@xstate/graph`

Remove `getMachineShortestPaths` and `getMachineSimplePaths`

```diff
import {
- getMachineShortestPaths,
+ getShortestPaths,
- getMachineSimplePaths,
+ getSimplePaths
} from '@xstate/graph';

-const paths = getMachineShortestPaths(machine);
+const paths = getShortestPaths(machine);

-const paths = getMachineSimplePaths(machine);
+const paths = getSimplePaths(machine);
```

---

The steps in the paths returned from functions like `getShortestPaths(...)` and `getSimplePaths(...)` have the following changes:

- The `step.event` property now represents the `event` object that resulted in the transition to the `step.state`, _not_ the event that comes before the next step.
- The `path.steps` array now includes the target `path.state` as the last step.
  - Note: this means that `path.steps` always has at least one step.
- The first `step` now has the `{ type: 'xstate.init' }` event

---
